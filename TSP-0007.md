# TSP-0007 — ANYPREVOUT Support for Eltoo-based Payment Channels (Tondi Flash)

**Proposal Number:** TSP-0007  
**Category:** Consensus (C) — _pre-Oct 2025 numbering retained as `000x`_   
**Status:** Review  
**Author:** Tondi Foundation & Avato Labs    
**Created:** 2025-09-05   
**Target:** Tondi Frontier → Tondi Mainnet (v2026a)    
**Scope:** On-chain payload schema, validation semantics, DAG ordering, data availability, zk/bridge extensions, governance mechanism  

## Introduction

### Abstract

This proposal describes a new type of public key for tapscript transactions in the Tondi blockchain. It allows signatures for these public keys to not commit to the exact UTXO being spent, enabling dynamic binding of transactions to different UTXOs provided they have compatible scripts. This enables the implementation of Eltoo-based payment channels, branded as Tondi Flash, for high-frequency micropayments.

### Copyright

This document is licensed under the 3-clause BSD license.

### Motivation

Off-chain protocols utilize unbroadcast transactions to renegotiate final states for on-chain settlement. In scenarios requiring predetermined responses to on-chain transactions, the same reaction may apply to multiple possible transactions. However, standard input signatures commit to the exact transaction, necessitating new signatures for each variant.

This proposal introduces a public key type that alters the transaction digest algorithm, excluding commitments to the previous output (and optionally the witness script and value). This permits dynamic rebinding of signed transactions to compatible previous outputs. The opt-in nature uses a distinct public key type, with rebinding scope restricted by keys, script commitments, amounts, nSequence values, or codeseparator opcodes.

Tondi, a high-performance DAG-based UTXO platform derived from Kaspa's GHOSTDAG/PHANTOM protocols, achieves sub-second confirmations and high TPS (>10,000). Optimized for micropayments (e.g., IoT, gaming, AI settlements), introducing ANYPREVOUT is essential for Tondi Flash—a simplified Eltoo payment network supporting millisecond updates and cross-chain bridging.

Bitcoin discussions on similar mechanisms highlighted concerns like replay risks, consensus splits, and upgrade timing. Tondi addresses these through enhanced bindings, contextual restrictions, and agile governance, transforming the feature from optional to core in its performance-oriented ecosystem.

## Specification

This proposal modifies the behavior of signature opcodes (CHECKSIG, CHECKSIGVERIFY, CHECKSIGADD) for public keys of 33 bytes starting with 0x01 or the single byte 0x01. These are termed TSP-0007 public keys.

### Rules for Signature Opcodes

The signature opcode rules are modified by excluding keys with first byte 0x01 and length 1 or 33 bytes from unknown public key types, adding this rule before handling unknowns:

- If the public key is the single byte 0x01, or 33 bytes with first byte 0x01, it is a TSP-0007 public key:
  - If the signature is not empty, validate it using Schnorr validation rules with the public key, allowable hash_type values, and modified transaction digest as defined below.

### Public Key

For the 1-byte TSP-0007 public key (0x01), use the 32-byte Taproot internal key p. For 33-byte keys, remove the 0x01 prefix and use the remaining 32 bytes.

### Signature Message

Define MsgTSP(hash_type) and ExtTSP(hash_type) for the signed message byte array. hash_type is an 8-bit unsigned value, including 0x00, 0x01, 0x02, 0x03, and new values 0x41, 0x42, 0x43, 0x81, 0x82, 0x83, 0xc1, 0xc2, 0xc3.

Constants:
- SIGHASH_ANYPREVOUT = 0x40
- SIGHASH_ANYPREVOUTANYSCRIPT = 0xc0

Restrictions (failure if violated):
- Undefined hash_type (not listed above).
- SIGHASH_SINGLE without corresponding output.

If valid, MsgTSP(hash_type) is:
- If hash_type & 0x40 == 0: Standard Tondi SigMsg(hash_type).
- If hash_type & 0x40 != 0: Concatenation of:
  - hash_type (1).
  - nVersion (4, little-endian).
  - nLockTime (4, little-endian).
  - If hash_type & 3 != SIGHASH_NONE or SIGHASH_SINGLE: sha_outputs (32, SHA256 of all outputs in CTxOut format).
  - spend_type (1: 2 if no annex, 3 if annex present with 0x50 prefix).
  - If hash_type & 0xc0 == SIGHASH_ANYPREVOUT: amount (8), scriptPubKey (35, serialized as in CTxOut).
  - nSequence (4).
  - If annex: sha_annex (32, SHA256 of compact_size(annex size) || annex).
  - If hash_type & 3 == SIGHASH_SINGLE: sha_single_output (32).

ExtTSP(hash_type):
- If hash_type & 0xc0 != SIGHASH_ANYPREVOUTANYSCRIPT: tapleaf_hash (32).
- key_version (1: 0x01).
- codesep_pos (4, little-endian: last OP_CODESEPARATOR position or 0xffffffff).

To verify signature sig for TSP-0007 public key p:
- If sig 64 bytes: Verify(p, hash_TapSigHash(0x00 || MsgTSP(0x00) || ExtTSP(0x00)), sig).
- If sig 65 bytes: sig[64] != 0x00 and Verify(p, hash_TapSigHash(0x00 || MsgTSP(sig[64]) || ExtTSP(sig[64])), sig[0:64]).
- Else fail.

Verify uses secp256k1 Schnorr verification.

Key differences from standard:
- key_version = 0x01.
- For SIGHASH_ANYPREVOUT: Digest as SIGHASH_ANYONECANPAY but exclude outpoint.
- For SIGHASH_ANYPREVOUTANYSCRIPT: Exclude outpoint, amount, scriptPubKey, tapleaf_hash.

### Script System Integration

#### Taproot Integration

Taproot uses Schnorr signatures for efficient ANYPREVOUT.

- Opcode Extension: CHECKSIG etc. use MsgTSP/ExtTSP for TSP keys, skipping prevout check, enforcing amount/nSequence.
- MuSig2 Aggregation: Two-round nonce exchange, partial signature aggregation for compact multi-sig.
- Example Script: <agg_pubkey> CHECKSIG.
- Implementation: In script::opcode module, extend exec_checksig with TSP logic using secp256k1_schnorrsig_verify.

#### Non-Taproot Integration

Compatible with Kaspa legacy scripts (P2PKH/P2SH/ECDSA).

- Opcode Extension: Similar, but ECDSA verification with secp256k1_ecdsa_verify.
- Example: OP_2 <pubkey1> <pubkey2> OP_2 OP_CHECKMULTISIG.
- Implementation: Modify exec_checksig for TSP keys, fallback to ECDSA; whitelist templates in p2p relay.

Comparison Table:

| Aspect        | Taproot ANYPREVOUT          | Non-Taproot ANYPREVOUT      |
|---------------|-----------------------------|-----------------------------|
| Signature Type| Schnorr/MuSig2 (aggregated)| ECDSA/Multi-sig (compatible)|
| On-Chain Size | ~32-64 bytes                | ~71-142 bytes               |
| Validation Speed | Fast (parallel Schnorr)   | Slower (sequential ECDSA)   |
| Compatibility | New ecosystems (upgrade req)| Kaspa upstream (seamless)   |
| Risk Mitigation | Merkle binding + amount check | Template whitelist + nSequence |

### Backward Compatibility and Activation

Soft fork: Unknown TSP keys invalidate transactions. Activation via signal blocks (version bit 3). Phased: Testnet 3 months, mainnet >75% nodes.

## Tondi Flash Protocol

Eltoo-based, with setup, negotiation, settlement phases.

### Channel Establishment (Setup)

Funding Tx locks to 2-of-2. Trigger Tx (ANYPREVOUT signed) outputs to update script.

Pseudocode:
```
let funding_out = Output::new(agg_pubkey, amount);
let funding_tx = Tx::new(inputs, [funding_out]);
sign_funding(parties);
broadcast(funding_tx);

let trigger_out = Output::new(update_script, amount); // OP_IF update_keys ELSE OP_CSV settlement_keys
let trigger_tx = Tx::spend(funding_out, trigger_out, ANYPREVOUT_flag);
exchange_sigs(trigger_tx);
```

### State Update (Negotiation)

New Update Tx with incremented nSequence, ANYPREVOUT reuse sig.

Pseudocode:
```
let new_balance = update_balance(old_balance, payment);
let update_tx = Tx::new(spend_prev_update, new_outputs, nSequence=i+1, ANYPREVOUT);
let partial = musig_partial_sign(key, nonce, update_tx.hash());
aggregate_sigs(partials);
let settlement_tx = Tx::spend(update_tx.out, final_outputs, OP_CSV_timeout);
exchange_and_store(update_tx, settlement_tx);
```

### High-Frequency Features

DAG confirms <1s, updates >10k/s/channel. Micropayments via HTLC variants, streaming payments.

### Routing and Bridging

MPP for multi-path; RGB/Nexus for cross-chain (BTC/Kaspa).

## Security

### Signature Replay

By design, SIGHASH_ANYPREVOUT and SIGHASH_ANYPREVOUTANYSCRIPT introduce additional potential for signature replay (that is they allow the same signature to be reused on a different transaction) when compared to SIGHASH_ALL and SIGHASH_ANYONECANPAY signatures.

Both SIGHASH_ALL and SIGHASH_ANYONECANPAY signatures prevent signature replay by committing to one or more inputs, so replay of the signature is only possible if the same input can be spent multiple times, which is not possible on the Tondi blockchain (due to enforcement of unique transaction IDs and UTXO management similar to BIP 30).

With SIGHASH_ANYPREVOUT signature replay is possible for different UTXOs with the same scriptPubKey and the same value, while with SIGHASH_ANYPREVOUTANYSCRIPT signature replay is possible for any UTXOs that reuse the same TSP-0007 public key in one of their potential scripts.

As a consequence, implementers MUST ensure that TSP-0007 public keys are only reused when signature replay cannot cause loss of funds (eg due to other features of the protocol or other constraints on the transaction, such as in Eltoo channels with nSequence ordering), or when such a loss of funds is acceptable.

### Malleability

Use of SIGHASH_ANYPREVOUT or SIGHASH_ANYPREVOUTANYSCRIPT may introduce additional malleability vectors.

In particular, a transaction authenticated using only ANYPREVOUT signatures is malleable to anyone able to provide an alternate input satisfied by the signature -- an input changed in this way would produce a new, valid transaction paying the same recipient, but with a different txid.

Depending on the changes to the inputs, this might conflict with the original transaction (if some inputs remain shared) or might result in a double-payment to the recipient (if they do not).

Further, for a chain of transactions using the same scriptPubKey and value, and only authenticated via ANYPREVOUT signatures (as envisioned in Eltoo for failure cases), it may be possible for any third party to malleate the transactions (and their txids) without having access to any of the private keys, particularly by omitting intermediate transactions.

This form of malleation can be dealt with by the child transactions also using ANYPREVOUT signatures -- when a parent transaction is malleated, its children can be adjusted to reference the new txid as the input and the ANYPREVOUT signatures remain valid.

However child transactions that are authorised by a SIGHASH_ALL or SIGHASH_ANYONECANPAY signature will need new signatures if their inputs are malleated in this way.

This risk may be mitigated somewhat by using relative time locks before spending a UTXO that had been authorised via an ANYPREVOUT signature with SIGHASH_ALL or SIGHASH_ANYONECANPAY: a relative timelock can ensure that the inputs have enough confirmations that they can only be replaced in the event of a large block reorg.

Note that this approach has drawbacks: relative timelocks prevent fee-bumping via child-pays-for-parent, and have the obvious drawback of making the funds temporarily unusable until the timelock expires.

### Privacy Considerations

It is expected that ANYPREVOUT signatures will only be rarely used in practice.

Protocol and wallet designers should aim to have their transactions use Taproot key path spends whenever possible, both for efficiency reasons due to the lower transaction weight, but also for privacy reasons to avoid third parties being able to distinguish their transactions from those of other protocols.

Transactions that do use ANYPREVOUT signatures will therefore reveal information about the transaction, potentially including that cooperation was impossible, or what protocol or software was used (due to the details of the script).

In order to maximise privacy, it is therefore recommended that protocol designers only use TSP-0007 public keys in scripts that will be spent using at least one ANYPREVOUT signature, and either use key path spends or alternate scripts in the Taproot merkle tree for any spends that can be authorised without ANYPREVOUT signatures.

Following this recommendation may require additional script branches, which may mean disregarding this recommendation may result in a better tradeoff between cost and privacy in some circumstances.

### Audit and Validation

To ensure robustness, implementations should undergo extensive fuzz testing (e.g., using sympy for probability simulations of replay attacks) and protocol simulations (e.g., with networkx for DAG load modeling). Benchmarks, such as those conducted with pandas analysis, demonstrate that Eltoo protocols enabled by this proposal reduce overall system complexity by approximately 70% compared to penalty-based mechanisms like traditional Lightning Network, primarily by eliminating revocation key management and toxic transaction risks.

## Rationale

New public key types for tapscript can be introduced in a soft fork by specifying new rules for unknown public key types, as this only requires adding restrictions to the pre-existing signature opcodes. Alternative approaches, such as defining new script opcodes, using a different Taproot leaf version, or different SegWit outputs, are more complicated and better reserved for upgrades needing additional flexibility. In this case, a new transaction digest is specified, but the same elliptic curve and signature algorithm (secp256k1 and Schnorr) are retained.

The Eltoo protocol provides an example where committing to the witness script is not always appropriate, using script and nLockTime to make signatures asymmetric, allowing earlier signatures to be spent by later ones but not vice versa. Thus, a single signature for a later transaction must spend prior ones with different tapscripts. However, committing to the script allows signatures for precisely one transaction. In Eltoo, this enables update transaction signatures applicable to any prior update and settlement signatures specific to corresponding updates, using the same key for compact scripts.

Committing to the input value enhances safety against malicious reuse for unintended funds, so it is default. However, excluding it allows consolidating UTXOs with identical spending conditions into one, useful for layered commitments with Eltoo.

This proposal supports ANYPREVOUT signatures only via script path spends, not key path spends, for independence from core Taproot changes and to allow addresses to opt-in or opt-out while remaining indistinguishable until spent.

Because OP_0 leaves an empty vector, it does not satisfy rules for unknown public key types. Using OP_1..OP_16 or OP_1NEGATE references the Taproot internal key simply; the first (0x01) is used, with the same byte as prefix for explicit keys.

Changing key_version ensures signatures for standard Taproot keys are not valid for TSP-0007 keys (and vice versa) if the same private key generates both.

OP_CODESEPARATOR affects both SIGHASH_ANYPREVOUT and SIGHASH_ANYPREVOUTANYSCRIPT signatures.

## Deployment

This may be deployed as a soft-fork either concurrent with, or subsequent to the deployment of Taproot-related upgrades in Tondi. Activation will use a version bit signaling mechanism, such as bit 3 in block headers, with a signaling period followed by a lock-in threshold (e.g., 75% of nodes/miners). Detailed activation parameters, including start and timeout heights, will be defined in a subsequent implementation proposal.

## Backward Compatibility

As a soft fork, older software will continue to operate without modification.

Nodes that have not upgraded to support Taproot will see all Taproot witness programs as anyone-can-spend scripts, and nodes that have upgraded to support Taproot but not TSP-0007 will simply treat any non-empty signature against a TSP-0007 public key as valid.

As such, nodes are strongly encouraged to upgrade in order to fully validate signatures for the new public key type.

Non-upgraded wallets can receive and send funds from non-upgraded and upgraded wallets using legacy outputs, traditional pay-to-pubkey-hash, etc. Depending on the implementation, non-upgraded wallets may be able to send to Taproot outputs if they support relevant address formats and do not prevent the transaction from being broadcast due to considering the outputs non-standard.

## Revisions

The ANYPREVOUT flag reflects that while any prevout may be used, aspects like input nSequence (and optionally spending conditions and amount) are committed to.

This proposal applies only to signatures via tapscript, not direct key path spends, requiring addresses to opt-in by including appropriate tapscript paths.

When SIGHASH_ANYPREVOUT is used, signatures commit to scriptPubKey and tapscript; when SIGHASH_ANYPREVOUTANYSCRIPT is used, they do not commit to output spending conditions.

SIGHASH_ANYPREVOUT commits to input amount; SIGHASH_ANYPREVOUTANYSCRIPT does not.

OP_CODESEPARATOR affects signatures.

Tondi-specific adaptations include support for Non-Taproot scripts to maintain Kaspa upstream compatibility and optimizations for DAG-based consensus, such as parallel validation enhancements.

## Acknowledgements

The ANYPREVOUT concept was first proposed by Joseph Poon in February 2016, after mention in the original Lightning paper by Joseph Poon and Thaddeus Dryja. This document results from discussions with many people and had direct input from Greg Maxwell, Jonas Nick, Pieter Wuille, Christian Decker, Anthony Towns, and others in the Bitcoin community. Additional thanks to the Tondi and Kaspa development teams for insights on DAG integration.

## References

- Eltoo: A Simple Layer2 Protocol for Bitcoin (Christian Decker et al.)
- Kaspa Documentation: GHOSTDAG/PHANTOM Protocols
- MuSig2: Simple Two-Round Schnorr Multi-Signatures
- Tondi Whitepaper (internal)