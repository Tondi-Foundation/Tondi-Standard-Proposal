# TSP-0007 — ANYPREVOUT Support for Eltoo-based Payment Channels (Tondi Flash)

**Proposal Number:** TSP-0007  
**Category:** Consensus (C) — _pre-Oct 2025 numbering retained as `000x`_   
**Status:** Review  
**Author:** Tondi Foundation Development Team & Avato Labs    
**Created:** 2025-09-05   
**Target:** Tondi Frontier → Tondi Mainnet (v2026a)    
**Scope:** On-chain payload schema, validation semantics, DAG ordering, data availability, zk/bridge extensions, governance mechanism  

This document uses the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" as described in RFC 2119.

## Introduction

### Abstract

This proposal describes a new type of public key and associated signature opcodes for tapscript transactions in the Tondi blockchain. It allows signatures for these public keys to not commit to the exact UTXO being spent, enabling dynamic binding of transactions to different UTXOs provided they have compatible scripts. This enables the implementation of Eltoo-based payment channels, branded as Tondi Flash, for high-frequency micropayments.

### Copyright

This document is licensed under the 3-clause BSD license.

### Motivation

Off-chain protocols utilize unbroadcast transactions to renegotiate final states for on-chain settlement. In scenarios requiring predetermined responses to on-chain transactions, the same reaction MAY apply to multiple possible transactions. However, standard input signatures commit to the exact transaction, necessitating new signatures for each variant.

This proposal introduces a public key type that alters the transaction digest algorithm, excluding commitments to the previous output (and optionally the witness script and value). This permits dynamic rebinding of signed transactions to compatible previous outputs. The opt-in nature uses a distinct public key type, with rebinding scope restricted by keys, script commitments, amounts, nSequence values, or codeseparator opcodes.

Tondi, a high-performance DAG-based UTXO platform derived from Kaspa's GHOSTDAG/PHANTOM protocols, achieves sub-second confirmations and high TPS (>10,000). Optimized for micropayments (e.g., IoT, gaming, AI settlements), introducing ANYPREVOUT is essential for Tondi Flash—a simplified Eltoo payment network supporting millisecond updates and cross-chain bridging.

Bitcoin discussions on similar mechanisms highlighted concerns like replay risks, consensus splits, and upgrade timing. Tondi addresses these through enhanced bindings, contextual restrictions, and agile governance, transforming the feature from optional to core in its performance-oriented ecosystem.

## Specification

This proposal modifies the behavior of signature opcodes for public keys of 33 bytes starting with 0x01 or the single byte 0x01. These are termed TSP-0007 public keys. ANYPREVOUT support is restricted to tapscript (witness version 1 or higher) contexts to ensure a soft fork. New opcodes (OP_CHECKSIG_TSP, OP_CHECKSIGVERIFY_TSP, OP_CHECKSIGADD_TSP) are introduced via OP_SUCCESSx encoding: unupgraded nodes treat them as unconditional success, while upgraded nodes enforce Schnorr validation with the modified digest, constituting a soft fork by tightening rules.

Non-tapscript paths (e.g., legacy P2PKH/P2SH) do not support ANYPREVOUT in this proposal; future extensions MAY introduce new witness versions or opcodes if needed.

### Rules for Signature Opcodes

The tapscript signature opcode rules are modified by defining new opcodes encoded as OP_SUCCESSx (e.g., opcode values in the 0xba-0xfe range reserved for future soft forks). Unupgraded nodes MUST treat these as success (no further execution), while upgraded nodes MUST perform the following:

- If the public key is the single byte 0x01, or 33 bytes with first byte 0x01, it is a TSP-0007 public key:
  - If the signature is not empty, validate it using Schnorr validation rules with the public key, allowable hash_type values, and modified transaction digest as defined below.
  - Failure to validate MUST cause the script to fail.

This tightening (from unconditional success to validated success) is a soft fork.

### Public Key and Signature Algorithm

TSP-0007 public keys are x-only 32-byte Schnorr public keys. Encoding rules:

- In scripts, identified as 0x01 || pubkey32 (33 bytes) for TSP-0007 public key type; or implicitly in tapscript key-path.
- Signature algorithm: secp256k1-Schnorr (BIP-340 style). ECDSA-APO is not defined.

### Terms and Constants

- Base SIGHASH: BASE = hash_type & 0x03, where 0x01=ALL, 0x02=NONE, 0x03=SINGLE.
- Bits: APO_BIT = 0x40, ANYSCRIPT_BIT = 0x80.
- Valid hash_type set: {0x01, 0x02, 0x03, 0x41, 0x42, 0x43, 0xC1, 0xC2, 0xC3}. Other values MUST fail.
- When hash_type & APO_BIT != 0, ANYONECANPAY legacy meaning is reserved and MUST NOT appear (i.e., 0x81..0x83 MUST fail).

### Signature Message (Domain Separation)

Use TaggedHash: H_tag(label, msg) = SHA256(SHA256(label) || SHA256(label) || msg); where label = "TSP-0007/APSighash".

Define MsgTSP(tx, in_idx, hash_type, annex?, leaf_hash?, codesep_pos):

1. u8: hash_type
2. le32: nVersion
3. le32: nLockTime
4. If BASE != NONE && BASE != SINGLE: H(Outputs) (all CTxOut concatenated with CompactSize length prefixes)
5. u8: spend_type (2=no annex, 3=has annex starting with 0x50)
6. If hash_type & APO_BIT != 0:
   - If hash_type & ANYSCRIPT_BIT == 0: bind le64: amount, varbytes: scriptPubKey (CompactSizeLen + RawScript)
   - Else (ANYSCRIPT): do not bind amount and scriptPubKey
7. le32: nSequence
8. If annex: H(CompactSizeLen(annex) || annex)
9. If BASE == SINGLE: H(Outputs[in_idx])

Define ExtTSP(hash_type, leaf_hash, codesep_pos):

- If hash_type & ANYSCRIPT_BIT == 0: leaf_hash(32); else omit
- u8: key_version = 0x01
- le32: codesep_pos (0xFFFFFFFF if no OP_CODESEPARATOR)

Full hash: sig_msg = H_tag("TSP-0007/APSighash", MsgTSP || ExtTSP).

### Validation Rules

- Signature length MUST be 64 or 65 bytes; if 65 bytes, the 65th byte is hash_type. For 64 bytes, default hash_type = 0x01 (ALL).
- Perform Schnorr validation with sig_msg and public key. Failure MUST cause script failure.

### Context and Soft Fork

- APO is effective only in tapscript (witness v1+). In tapscript, introduced via new opcodes OP_CHECKSIG_TSP / OP_CHECKSIGADD_TSP encoded as OP_SUCCESSx; unupgraded nodes treat as unconditional success, upgraded nodes tighten to Schnorr+APO validation, forming a soft fork.
- Non-tapscript paths do not activate APO (future TSP MAY extend if needed).

### Script System Integration

ANYPREVOUT is tapscript-only, using Schnorr signatures for efficiency.

- Opcode Extension: New OP_CHECKSIG_TSP etc. use MsgTSP/ExtTSP for TSP keys, skipping prevout check, enforcing amount/nSequence (when not ANYSCRIPT).
- MuSig2 Aggregation: Two-round nonce exchange, partial signature aggregation for compact multi-sig.
- Example Script: <agg_pubkey> OP_CHECKSIG_TSP.
- Implementation: In script::opcode module, extend execution for new opcodes with TSP logic using secp256k1_schnorrsig_verify.

Non-Taproot (legacy) integration is not supported for ANYPREVOUT in this version; future proposals MAY add via new witness versions.

### DAG/Mempool Policies (Replace-By-Sequence - RBS)

To leverage Tondi's DAG, introduce Replace-By-Sequence (RBS) and Last-State-Wins rules:

- Channel transactions are clustered by {funding_outpoint, channel_id}.
- Higher nSequence commitment transactions automatically replace lower versions in mempool and DAG conflict resolution.
- Tie-breaks: higher fee, higher nSequence, newer timestamp.
- Policy: Non-channel template APO transactions MUST NOT be relayed by default (opt-in whitelist) to reduce misuse.

### Backward Compatibility and Activation

As a soft fork, older software will continue to operate without modification.

Unupgraded nodes treat new OP_SUCCESSx opcodes as success, validating transactions but not enforcing new signatures. Upgraded nodes tighten validation.

Nodes are strongly encouraged to upgrade to fully validate new signatures.

Non-upgraded wallets can use legacy outputs.

Activation: Soft fork via version bit 3 signaling. Phased: 3-month testnet, mainnet threshold 80% over 2016 blocks, observation period with Speedy Trial (LOT=true for activation lock-in). Fallback if not met within timeout.

## Tondi Flash Protocol

Eltoo-based, with setup, negotiation, settlement phases.

### Channel Establishment (Setup)

Funding Tx locks to 2-of-2. Trigger Tx (ANYPREVOUT signed) outputs to update script.

Pseudocode:
```
let funding_out = Output::new(agg_pubkey, amount);
let funding_tx = Tx::new(inputs, [funding_out]);
sign_funding(parties);
broadcast(funding_tx);

let trigger_out = Output::new(update_script, amount); // OP_IF update_keys ELSE OP_CSV settlement_keys
let trigger_tx = Tx::spend(funding_out, trigger_out, ANYPREVOUT_flag);
exchange_sigs(trigger_tx);
```

### State Update (Negotiation)

New Update Tx with incremented nSequence, ANYPREVOUT reuse sig.

Pseudocode:
```
let new_balance = update_balance(old_balance, payment);
let update_tx = Tx::new(spend_prev_update, new_outputs, nSequence=i+1, ANYPREVOUT);
let partial = musig_partial_sign(key, nonce, update_tx.hash());
aggregate_sigs(partials);
let settlement_tx = Tx::spend(update_tx.out, final_outputs, OP_CSV_timeout);
exchange_and_store(update_tx, settlement_tx);
```

### High-Frequency Features

DAG confirms <1s, updates >10k/s/channel. Micropayments via HTLC variants, streaming payments.

### Routing and Bridging

MPP for multi-path; RGB/Nexus for cross-chain (BTC/Kaspa).

## Security

### Signature Replay

By design, SIGHASH_ANYPREVOUT and SIGHASH_ANYPREVOUTANYSCRIPT introduce additional potential for signature replay compared to SIGHASH_ALL and SIGHASH_ANYONECANPAY.

Standard signatures prevent replay by committing to inputs; replay requires spending the same input multiple times, impossible on Tondi (unique txids/UTXOs).

With SIGHASH_ANYPREVOUT, replay possible for different UTXOs with same scriptPubKey and value; with SIGHASH_ANYPREVOUTANYSCRIPT, for any UTXOs reusing the same TSP-0007 key.

Implementers MUST ensure TSP-0007 keys are only reused where replay cannot cause fund loss (e.g., Eltoo with nSequence ordering), or where acceptable.

Wallet SDKs MUST default to allowing APO only in channel templates; enforce bindings for amount, nSequence, tapleaf_hash (non-ANYSCRIPT); recommend minimum CSV/CLTV timeouts.

### Malleability

ANYPREVOUT MAY introduce malleability vectors.

Transactions using only ANYPREVOUT signatures are malleable by providing alternate satisfied inputs, creating new valid tx with different txid, potentially conflicting or double-paying.

For Eltoo chains, third parties MAY malleate without keys by omitting intermediates.

Mitigate by using ANYPREVOUT in child txs to adjust txids; or relative timelocks for SIGHASH_ALL/ANYONECANPAY children to ensure confirmations against reorgs.

Drawbacks: Timelocks prevent CPFP fee-bumping and delay funds.

### Privacy Considerations

ANYPREVOUT signatures expected rare.

Designers SHOULD use Taproot key path spends for efficiency and privacy, avoiding distinction from other protocols.

ANYPREVOUT usage reveals info (e.g., non-cooperation, protocol details).

To maximize privacy, use TSP-0007 keys only in scripts spent with ANYPREVOUT; use key paths or alternate Merkle branches for non-ANYPREVOUT spends.

Additional branches MAY trade cost for privacy.

### Audit and Validation

Implementations MUST undergo fuzz testing (e.g., sympy for replay probabilities) and simulations (networkx for DAG). Benchmarks (pandas) show Eltoo reduces complexity ~70% vs. penalty-based (no revocations/toxics).

Watchtowers SHOULD provide non-punitive proofs, with minimal data retention and on-chain response windows matching sub-second confirmations.

## Rationale

New public key types for tapscript can be introduced in a soft fork by specifying new rules for unknown public key types, as this only requires adding restrictions to the pre-existing signature opcodes. Alternative approaches, such as defining new script opcodes, using a different Taproot leaf version, or different SegWit outputs, are more complicated and better reserved for upgrades needing additional flexibility. In this case, a new transaction digest is specified, but the same elliptic curve and signature algorithm (secp256k1 and Schnorr) are retained.

The Eltoo protocol provides an example where committing to the witness script is not always appropriate, using script and nLockTime to make signatures asymmetric, allowing earlier signatures to be spent by later ones but not vice versa. Thus, a single signature for a later transaction must spend prior ones with different tapscripts. However, committing to the script allows signatures for precisely one transaction. In Eltoo, this enables update transaction signatures applicable to any prior update and settlement signatures specific to corresponding updates, using the same key for compact scripts.

Committing to the input value enhances safety against malicious reuse for unintended funds, so it is default. However, excluding it allows consolidating UTXOs with identical spending conditions into one, useful for layered commitments with Eltoo.

This proposal supports ANYPREVOUT signatures only via script path spends, not key path spends, for independence from core Taproot changes and to allow addresses to opt-in or opt-out while remaining indistinguishable until spent.

Because OP_0 leaves an empty vector, it does not satisfy rules for unknown public key types. Using OP_1..OP_16 or OP_1NEGATE references the Taproot internal key simply; the first (0x01) is used, with the same byte as prefix for explicit keys.

Changing key_version ensures signatures for standard Taproot keys are not valid for TSP-0007 keys (and vice versa) if the same private key generates both.

OP_CODESEPARATOR affects both SIGHASH_ANYPREVOUT and SIGHASH_ANYPREVOUTANYSCRIPT signatures.

## Deployment

This MAY be deployed as a soft-fork concurrent with or subsequent to Taproot upgrades in Tondi. Activation uses version bit 3 signaling, with 2016-block periods, 80% threshold, 3-month testnet prelude, observation period, and Speedy Trial with LOT=true for lock-in. Fallback if timeout unmet.

## Backward Compatibility

As a soft fork, older software continues without modification.

Unupgraded nodes see OP_SUCCESSx as success, validating txs but not signatures. Upgraded enforce fully.

Encourage upgrades for validation.

Non-upgraded wallets use legacy.

## Revisions

ANYPREVOUT flag reflects commitment to nSequence (optionally conditions/amount).

Applies only to tapscript; addresses opt-in via paths.

SIGHASH_ANYPREVOUT commits to scriptPubKey/tapscript; SIGHASH_ANYPREVOUTANYSCRIPT does not.

SIGHASH_ANYPREVOUT commits to amount; SIGHASH_ANYPREVOUTANYSCRIPT does not.

OP_CODESEPARATOR affects signatures.

Tondi adaptations: Non-Taproot deferred, DAG RBS added.

## Test Vectors

Positive (6 groups): ALL/NONE/SINGLE × (APO / APO|ANYSCRIPT), with/without annex, CODESEPARATOR.

Negative (4): Invalid flags (0x81), SINGLE out-of-bounds, illegal lengths/prefixes, failed Schnorr.

[Detailed vectors TBD in impl; pseudocode for failures in ref impl.]

## Reference Implementation

Pseudocode for failures: Check hash_type in valid set; verify lengths; etc.

## BTC Community Historical Concerns and Resolutions

- Replay/Misuse: Via valid flag set, mandatory bindings (non-ANYSCRIPT) + whitelists/wallet restrictions, confined to channels.
- Upgrade Risk: Tapscript-only + OP_SUCCESS tightening → soft fork; phased activation/observation.
- Necessity: Tondi prioritizes high-frequency payments; APO essential, not optional, with DAG+RBS enabling Eltoo UX/throughput.

## Non-Normative Appendix: ZK/Bridge Extensions

[Deferred for future TSP.]

## References

- Eltoo: A Simple Layer2 Protocol for Bitcoin (Christian Decker et al.)
- Kaspa Documentation: GHOSTDAG/PHANTOM Protocols
- MuSig2: Simple Two-Round Schnorr Multi-Signatures
- Tondi Whitepaper (internal)
- RFC 2119: Key words for use in RFCs to Indicate Requirement Levels