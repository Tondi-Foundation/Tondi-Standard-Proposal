# TSP-0007 FUN20 — ANYPREVOUT Support for Eltoo-based Payment Channels (Tondi Flash)

**Proposal Number:** TSP-0007
**Category:** Consensus (C) — _pre-Oct 2025 numbering retained as `000x`_  
**Status:** Review
**Author:** Tondi Foundation & Avato Labs  
**Created:** 2025-09-05 
**Target:** Tondi Frontier → Tondi Mainnet (v2026a)  
**Scope:** On-chain payload schema, validation semantics, DAG ordering, data availability, zk/bridge extensions, governance mechanism



## Introduction

### Abstract

This proposal describes a new type of public key for tapscript transactions in the Tondi blockchain. It allows signatures for these public keys to not commit to the exact UTXO being spent, enabling dynamic binding of transactions to different UTXOs provided they have compatible scripts. This enables the implementation of Eltoo-based payment channels, branded as Tondi Flash, for high-frequency micropayments.

### Copyright

This document is licensed under the 3-clause BSD license.

### Motivation

Off-chain protocols utilize unbroadcast transactions to renegotiate final states for on-chain settlement. In scenarios requiring predetermined responses to on-chain transactions, the same reaction may apply to multiple possible transactions. However, standard input signatures commit to the exact transaction, necessitating new signatures for each variant.

This proposal introduces a public key type that alters the transaction digest algorithm, excluding commitments to the previous output (and optionally the witness script and value). This permits dynamic rebinding of signed transactions to compatible previous outputs. The opt-in nature uses a distinct public key type, with rebinding scope restricted by keys, script commitments, amounts, nSequence values, or codeseparator opcodes.

Tondi, a high-performance DAG-based UTXO platform derived from Kaspa's GHOSTDAG/PHANTOM protocols, achieves sub-second confirmations and high TPS (>10,000). Optimized for micropayments (e.g., IoT, gaming, AI settlements), introducing ANYPREVOUT is essential for Tondi Flash—a simplified Eltoo payment network supporting millisecond updates and cross-chain bridging.

Bitcoin discussions on similar mechanisms highlighted concerns like replay risks, consensus splits, and upgrade timing. Tondi addresses these through enhanced bindings, contextual restrictions, and agile governance, transforming the feature from optional to core in its performance-oriented ecosystem.

## Specification

This proposal modifies the behavior of signature opcodes (CHECKSIG, CHECKSIGVERIFY, CHECKSIGADD) for public keys of 33 bytes starting with 0x01 or the single byte 0x01. These are termed TSP-0007 public keys.

### Rules for Signature Opcodes

The signature opcode rules are modified by excluding keys with first byte 0x01 and length 1 or 33 bytes from unknown public key types, adding this rule before handling unknowns:

- If the public key is the single byte 0x01, or 33 bytes with first byte 0x01, it is a TSP-0007 public key:
  - If the signature is not empty, validate it using Schnorr validation rules with the public key, allowable hash_type values, and modified transaction digest as defined below.

### Public Key

For the 1-byte TSP-0007 public key (0x01), use the 32-byte Taproot internal key p. For 33-byte keys, remove the 0x01 prefix and use the remaining 32 bytes.

### Signature Message

Define MsgTSP(hash_type) and ExtTSP(hash_type) for the signed message byte array. hash_type is an 8-bit unsigned value, including 0x00, 0x01, 0x02, 0x03, and new values 0x41, 0x42, 0x43, 0x81, 0x82, 0x83, 0xc1, 0xc2, 0xc3.

Constants:
- SIGHASH_ANYPREVOUT = 0x40
- SIGHASH_ANYPREVOUTANYSCRIPT = 0xc0

Restrictions (failure if violated):
- Undefined hash_type (not listed above).
- SIGHASH_SINGLE without corresponding output.

If valid, MsgTSP(hash_type) is:
- If hash_type & 0x40 == 0: Standard Tondi SigMsg(hash_type).
- If hash_type & 0x40 != 0: Concatenation of:
  - hash_type (1).
  - nVersion (4, little-endian).
  - nLockTime (4, little-endian).
  - If hash_type & 3 != SIGHASH_NONE or SIGHASH_SINGLE: sha_outputs (32, SHA256 of all outputs in CTxOut format).
  - spend_type (1: 2 if no annex, 3 if annex present with 0x50 prefix).
  - If hash_type & 0xc0 == SIGHASH_ANYPREVOUT: amount (8), scriptPubKey (35, serialized as in CTxOut).
  - nSequence (4).
  - If annex: sha_annex (32, SHA256 of compact_size(annex size) || annex).
  - If hash_type & 3 == SIGHASH_SINGLE: sha_single_output (32).

ExtTSP(hash_type):
- If hash_type & 0xc0 != SIGHASH_ANYPREVOUTANYSCRIPT: tapleaf_hash (32).
- key_version (1: 0x01).
- codesep_pos (4, little-endian: last OP_CODESEPARATOR position or 0xffffffff).

To verify signature sig for TSP-0007 public key p:
- If sig 64 bytes: Verify(p, hash_TapSigHash(0x00 || MsgTSP(0x00) || ExtTSP(0x00)), sig).
- If sig 65 bytes: sig[64] != 0x00 and Verify(p, hash_TapSigHash(0x00 || MsgTSP(sig[64]) || ExtTSP(sig[64])), sig[0:64]).
- Else fail.

Verify uses secp256k1 Schnorr verification.

Key differences from standard:
- key_version = 0x01.
- For SIGHASH_ANYPREVOUT: Digest as SIGHASH_ANYONECANPAY but exclude outpoint.
- For SIGHASH_ANYPREVOUTANYSCRIPT: Exclude outpoint, amount, scriptPubKey, tapleaf_hash.

### Script System Integration

#### Taproot Integration

Taproot uses Schnorr signatures for efficient ANYPREVOUT.

- Opcode Extension: CHECKSIG etc. use MsgTSP/ExtTSP for TSP keys, skipping prevout check, enforcing amount/nSequence.
- MuSig2 Aggregation: Two-round nonce exchange, partial signature aggregation for compact multi-sig.
- Example Script: <agg_pubkey> CHECKSIG.
- Implementation: In script::opcode module, extend exec_checksig with TSP logic using secp256k1_schnorrsig_verify.

#### Non-Taproot Integration

Compatible with Kaspa legacy scripts (P2PKH/P2SH/ECDSA).

- Opcode Extension: Similar, but ECDSA verification with secp256k1_ecdsa_verify.
- Example: OP_2 <pubkey1> <pubkey2> OP_2 OP_CHECKMULTISIG.
- Implementation: Modify exec_checksig for TSP keys, fallback to ECDSA; whitelist templates in p2p relay.

Comparison Table:

| Aspect        | Taproot ANYPREVOUT          | Non-Taproot ANYPREVOUT      |
|---------------|-----------------------------|-----------------------------|
| Signature Type| Schnorr/MuSig2 (aggregated)| ECDSA/Multi-sig (compatible)|
| On-Chain Size | ~32-64 bytes                | ~71-142 bytes               |
| Validation Speed | Fast (parallel Schnorr)   | Slower (sequential ECDSA)   |
| Compatibility | New ecosystems (upgrade req)| Kaspa upstream (seamless)   |
| Risk Mitigation | Merkle binding + amount check | Template whitelist + nSequence |

### Backward Compatibility and Activation

Soft fork: Unknown TSP keys invalidate transactions. Activation via signal blocks (version bit 3). Phased: Testnet 3 months, mainnet >75% nodes.

## Tondi Flash Protocol

Eltoo-based, with setup, negotiation, settlement phases.

### Channel Establishment (Setup)

Funding Tx locks to 2-of-2. Trigger Tx (ANYPREVOUT signed) outputs to update script.

Pseudocode:
```
let funding_out = Output::new(agg_pubkey, amount);
let funding_tx = Tx::new(inputs, [funding_out]);
sign_funding(parties);
broadcast(funding_tx);

let trigger_out = Output::new(update_script, amount); // OP_IF update_keys ELSE OP_CSV settlement_keys
let trigger_tx = Tx::spend(funding_out, trigger_out, ANYPREVOUT_flag);
exchange_sigs(trigger_tx);
```

### State Update (Negotiation)

New Update Tx with incremented nSequence, ANYPREVOUT reuse sig.

Pseudocode:
```
let new_balance = update_balance(old_balance, payment);
let update_tx = Tx::new(spend_prev_update, new_outputs, nSequence=i+1, ANYPREVOUT);
let partial = musig_partial_sign(key, nonce, update_tx.hash());
aggregate_sigs(partials);
let settlement_tx = Tx::spend(update_tx.out, final_outputs, OP_CSV_timeout);
exchange_and_store(update_tx, settlement_tx);
```

### High-Frequency Features

DAG confirms <1s, updates >10k/s/channel. Micropayments via HTLC variants, streaming payments.

### Routing and Bridging

MPP for multi-path; RGB/Nexus for cross-chain (BTC/Kaspa).

## Security

### Signature Replay

ANYPREVOUT allows replay on same scriptPubKey/value UTXOs; ANYPREVOUTANYSCRIPT on same key. Implementers MUST restrict TSP keys to protocols where replay doesn't cause loss (e.g., channels with nSequence ordering).

### Malleability

ANYPREVOUT introduces malleability; mitigate with relative timelocks (BIP-68/112) for child Tx, or ANYPREVOUT in children to adjust txids.

### Privacy

Use key path spends primarily; TSP keys only in ANYPREVOUT-required scripts.

Audit: Fuzz testing, simulations; benchmarks show Eltoo reduces complexity 70% vs. penalty-based.

## Rationale

New public key type for soft fork simplicity. Optional script/amount commitment for Eltoo asymmetry vs. precision. Script-path only for opt-in addresses. key_version=0x01 prevents cross-key validity.

## Deployment

Concurrent or post Tondi core upgrades. Soft fork via signaled height.

## Backward Compatibility

Older software operates; unupgraded nodes treat TSP signatures as valid but unvalidated. Encourage upgrades. Non-upgraded wallets use legacy outputs.

## Revisions

Tondi adaptations include Non-Taproot support, DAG optimizations.

## Acknowledgements

Inspired by discussions from Joseph Poon, Thaddeus Dryja, Christian Decker, Anthony Towns, Greg Maxwell, Jonas Nick, Pieter Wuille.

## References

- Eltoo: A Simple Layer2 Protocol for Bitcoin (Christian Decker et al.)
- Kaspa Documentation: GHOSTDAG/PHANTOM Protocols
- MuSig2: Simple Two-Round Schnorr Multi-Signatures
- Tondi Whitepaper (internal)