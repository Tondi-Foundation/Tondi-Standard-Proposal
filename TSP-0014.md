# TSP-0014 — Tondi-Flash: Eltoo Channels

| Field | Value |
|-------|-------|
| **Proposal Number** | TSP-0014 |
| **Category** | Consensus / Layer-2 |
| **Status** | Draft |
| **Author** | Avato Labs |
| **Created** | 2025-09-23 |
| **Target** | Tondi Frontier (v2026a) |
| **Scope** | Layer-2 protocol specification, mempool relay policies, channel templates, watchtower integration, governance mechanism |
| **Dependencies** | TSP-0007 (ANYPREVOUT / OP_CHECKSIG_APO) |

## RFC 2119 Compliance

This document uses the key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" as described in RFC 2119.

## Introduction
### Abstract
This proposal specifies Tondi-Flash, a Layer-2 payment channel mechanism for the Tondi blockchain, based on the Eltoo protocol [Decker, Russell, Osuntokun 2018]. Tondi-Flash leverages OP_CHECKSIG_APO (OP_SUCCESS200) from TSP-0007 to enable Last-State-Wins channel updates, replacing the penalty-based model of the Lightning Network [BOLT Specifications]. To support state replacement, this proposal introduces an opt-in Replace-By-Sequence (RBS) mempool relay domain, isolated from the existing Replace-By-Fee (RBF) policy. This enables efficient, high-frequency off-chain payments optimized for Tondi's DAG-based consensus, supporting applications like micropayments, streaming payments, and cross-chain bridges.

### Motivation
#### Challenges with Penalty-Based Channels
The Lightning Network's penalty-based channels impose operational and security burdens:

- **Storage Overhead**: Parties must store all past states to enforce revocation, creating storage and management overhead
- **Watchtower Complexity**: Watchtowers must retain and broadcast punitive transactions, increasing complexity and potential for errors
- **Pinning Attacks**: Replacement by fee (RBF) exposes channel users to pinning attacks, where an adversary submits a large, low-fee earlier state that is costly to replace [BIP125 critique]
- **Toxic Waste**: Revocation keys introduce risks of data loss leading to fund theft

#### Benefits of Eltoo and Last-State-Wins
Eltoo [Decker et al. 2018] solves these issues by allowing channel updates to be replaced by later states signed with ANYPREVOUT. The result is:

- **Last-State-Wins**: Only the latest valid state can be settled, eliminating the need for revocations and penalties
- **Watchtower Simplification**: Only the latest state must be monitored, reducing storage and communication requirements
- **Fee Efficiency**: Updates can be fee-adjusted without penalty logic, mitigating pinning attacks
- **Symmetric Design**: Both parties use the same script and signature types, simplifying implementation

#### Tondi Platform Advantages
Tondi's DAG-based consensus (derived from Kaspa's GHOSTDAG/PHANTOM) enables sub-second confirmations and high TPS (>10,000), making it ideal for high-frequency Eltoo channels. ANYPREVOUT from TSP-0007 transforms Eltoo from a theoretical protocol to core infrastructure, enabling:

- **Micropayments**: IoT, gaming, and AI settlements
- **Channel Factories**: Scalable multi-user channels
- **Cross-Chain Integration**: Statechains and cross-chain bridges

#### Tondi-Flash Application Ecosystem
```
Tondi-Flash (Eltoo Channels)
├── Payment Channels
│ ├── Single-User Channels
│ │ ├── High-frequency micropayments
│ │ ├── Streaming payments
│ │ └── Symmetric updates
│ └── Channel Factories
│ ├── Multi-user batch channels
│ ├── Dynamic join/leave
│ └── Pre-signed updates
├── Off-Chain Protocols
│ ├── Statechains
│ │ ├── Ownership transfer
│ │ ├── Off-chain custody
│ │ └── Sequence-based ordering
│ └── Payment Aggregation
│ ├── Multi-UTXO batching
│ ├── Fee optimization
│ └── Micropayment consolidation
├── Cross-Chain Infrastructure
│ ├── Bridge Protocols
│ │ ├── Emergency refunds
│ │ ├── Multi-chain redemptions
│ │ └── Atomic settlements
│ └── Atomic Swaps
│ ├── HTLC variants
│ ├── Time-locked contracts
│ └── Cross-chain routing
├── Advanced Applications
│ ├── IoT Settlements
│ ├── Gaming Economies
│ ├── AI Microtransactions
│ └── Multi-Path Payments (MPP)
└── Watchtower Services
    ├── Simplified monitoring
    ├── Storage optimization
    └── Non-punitive proofs
```

## Specification

This proposal defines the Tondi-Flash protocol using ANYPREVOUT signatures from TSP-0007. Channels are opt-in via specific script templates and use RBS for mempool and DAG conflict resolution.

### Dependencies

- **TSP-0007 (ANYPREVOUT)**: MUST be active
- **OP_CHECKSIG_APO**: Nodes MUST implement OP_CHECKSIG_APO (OP_SUCCESS200), OP_CHECKSIGVERIFY_APO (OP_SUCCESS201), and OP_CHECKSIGADD_APO (OP_SUCCESS202)
- **Taproot and Schnorr**: MUST be supported for MuSig2 aggregation (BIP340-equivalent)
- **MuSig2**: Required for aggregate keys in funding outputs

### Terms and Constants

#### Core Terminology Definitions

| Term | Definition |
|------|------------|
| **Tondi-Flash Channel** | A Layer-2 payment channel using Eltoo mechanics, where updates are rebindable via ANYPREVOUT signatures |
| **Funding Transaction** | On-chain transaction locking funds into a 2-of-2 MuSig2 output |
| **Trigger Transaction** | Initial off-chain transaction signed with ANYPREVOUT, spending the funding output to an update script |
| **Update Transaction** | Off-chain transaction with incremented nSequence, spending prior trigger/update outputs using the same ANYPREVOUT signature |
| **Settlement Transaction** | Final on-chain transaction spending the latest update output to participants' addresses, with optional CSV/CLTV delays |
| **Replace-By-Sequence (RBS)** | Mempool policy allowing replacement of channel transactions by higher nSequence versions |
| **Channel ID** | Unique identifier derived from funding outpoint and aggregate public key |

#### Security Parameters

| Parameter | Value | Description |
|-----------|-------|-------------|
| **nSequence Increment** | ≥ 1 | MUST be strictly increasing by at least 1 per update |
| **CSV/CLTV Delays** | 10 blocks | RECOMMENDED minimum (sub-second in Tondi) for dispute windows |
| **Hash Type** | 0x41 | Default (SIGHASH_ALL \| APO_BIT) for amount and script binding |
| **ANYSCRIPT_BIT** | Optional | For flexible scripts, but MUST be whitelisted for relay |
| **Domain Separation** | "Tondi-Flash/ChannelSig" | Tag for signatures |

#### Valid Configurations

Channels MUST use TSP-0007 public keys (0x01 prefix). Valid hash types are subsets of TSP-0007: `{0x41, 0x42, 0x43, 0xC1, 0xC2, 0xC3}`.

### Channel Lifecycle

1. **Funding Phase**
   - Create 2-of-2 MuSig2 funding output
   - Broadcast funding transaction

2. **Trigger Phase**
   - Create trigger transaction spending funding output with ANYPREVOUT signature (hash_type=0x41)
   - Output to update script

3. **Update Phase**
   - For each state change, create new update transaction with higher nSequence
   - Reuse trigger signature (rebindable via ANYPREVOUT)
   - Exchange and store new update and settlement transactions

4. **Settlement Phase**
   - Broadcast latest update transaction
   - After CSV delay, broadcast settlement to claim funds

5. **Cooperative Close**
   - Mutually sign and broadcast a direct settlement from funding output

6. **Uncooperative Close**
   - Broadcast latest update; opponent has CSV window to challenge with higher sequence

### Script Templates

#### Funding Script (2-of-2 MuSig2)

```script
OP_2 <agg_pubkey> OP_2 OP_CHECKMULTISIG
```

- `agg_pubkey`: MuSig2 aggregate of participants' keys

#### Update Script (Conditional Branching)

```script
OP_IF
  // Cooperative update branch
  OP_2 <update_pubkey1> <update_pubkey2> OP_2 OP_CHECKMULTISIG_APO
OP_ELSE
  // Settlement branch with CSV delay
  <csv_delay> OP_CHECKSEQUENCEVERIFY OP_DROP
  OP_2 <settlement_pubkey1> <settlement_pubkey2> OP_2 OP_CHECKMULTISIG
OP_ENDIF
```

- `update_pubkey1/2`: TSP-0007 keys for ANYPREVOUT signatures
- `settlement_pubkey1/2`: Standard keys for final claims
- `csv_delay`: Relative timelock (e.g., 10 blocks)

#### Settlement Script

Direct P2TR or P2WPKH outputs to participants.

### Binding Mechanisms

| Mechanism | Description |
|-----------|-------------|
| **Sequence Binding** | Always committed to prevent replays |
| **Amount Binding** | Default (unless ANYSCRIPT_BIT) |
| **Script Binding** | Default to update script template |
| **Tapleaf Binding** | Committed for script version consistency |

### Usage Examples and Code Patterns

#### Example 1: Channel Funding and Trigger

```rust
// Generate MuSig2 aggregate key
let agg_pubkey = musig2_aggregate([pubkey1, pubkey2]);

// Create funding script
let funding_script = Script::new(vec![
    Opcode::OP_2,
    Opcode::OP_PUSH32, agg_pubkey.to_bytes(),
    Opcode::OP_2,
    Opcode::OP_CHECKMULTISIG,
]);

// Create and broadcast funding tx
let funding_tx = create_funding_tx(inputs, funding_script, channel_amount);
broadcast(&funding_tx);

// Create update script (as above)
let update_script = create_update_script(update_pubkeys, settlement_pubkeys, csv_delay);

// Create trigger tx with ANYPREVOUT
let trigger_tx = Transaction {
    inputs: vec![Input {
        previous_output: funding_tx.outpoint(0),
        sequence: 0,
    }],
    outputs: vec![Output { script_pubkey: update_script, value: channel_amount }],
};

let trigger_sig = sign_anyprevout(privkey, &trigger_tx, 0, 0x41);
exchange_sigs(&trigger_sig);
```

#### Example 2: State Update

```rust
// From previous update_tx
let new_sequence = previous_sequence + 1;
let new_update_tx = Transaction {
    inputs: vec![Input {
        previous_output: previous_update_tx.outpoint(0),
        sequence: new_sequence,
    }],
    outputs: vec![Output { script_pubkey: update_script.clone(), value: channel_amount }],
};

// Reuse trigger signature
let update_sig = trigger_sig.clone();
assert!(verify_anyprevout(&update_sig, &new_update_tx, 0, update_pubkey));

// Create corresponding settlement tx
let settlement_tx = create_settlement_tx(&new_update_tx, new_balances, csv_delay);
exchange_and_store(&new_update_tx, &settlement_tx);
```

#### Example 3: Settlement and Dispute

```rust
// Broadcast latest update_tx
broadcast(&latest_update_tx);

// After CSV delay, broadcast settlement
if is_after_csv(latest_update_tx.confirmation_time, csv_delay) {
    broadcast(&settlement_tx);
}

// Dispute: Broadcast higher sequence update if available
if opponent_broadcast.sequence < my_latest.sequence {
    broadcast(&my_latest_update_tx);
}
```

### Technical Implementation Details

#### Algorithms

##### 1. Channel State Update Algorithm

```rust
fn update_channel_state(
    previous_tx: &Transaction,
    new_balances: (u64, u64),
    sequence_increment: u32,
    update_script: &Script,
) -> (Transaction, Transaction) {
    let new_sequence = previous_tx.inputs[0].sequence + sequence_increment;
    let update_tx = Transaction {
        inputs: vec![Input {
            previous_output: previous_tx.outpoint(0),
            sequence: new_sequence,
        }],
        outputs: vec![Output { 
            script_pubkey: update_script.clone(), 
            value: previous_tx.outputs[0].value 
        }],
    };
    let settlement_tx = Transaction {
        inputs: vec![Input {
            previous_output: update_tx.outpoint(0),
            sequence: csv_delay,
        }],
        outputs: vec![
            Output { script_pubkey: p2wpkh(alice_addr), value: new_balances.0 },
            Output { script_pubkey: p2wpkh(bob_addr), value: new_balances.1 },
        ],
    };
    (update_tx, settlement_tx)
}
```

##### 2. Signature Reuse Validation

```rust
fn validate_signature_reuse(
    sig: &[u8],
    tx: &Transaction,
    input_idx: usize,
    pubkey: &TSP0007PublicKey,
) -> bool {
    let hash_type = extract_hash_type(sig);
    let msg = construct_signature_message(tx, input_idx, hash_type, None, None, 0xFFFFFFFF);
    schnorr_verify(&sig[0..64], &msg, &pubkey.pubkey)
}
```

##### 3. RBS Conflict Resolution

```rust
fn resolve_rbs_conflict(tx1: &Transaction, tx2: &Transaction) -> Transaction {
    if tx2.inputs[0].sequence > tx1.inputs[0].sequence {
        return tx2.clone();
    } else if tx2.inputs[0].sequence == tx1.inputs[0].sequence {
        if tx2.feerate() > tx1.feerate() {
            return tx2.clone();
        } else if tx2.wtxid() < tx1.wtxid() {  // Lex order
            return tx2.clone();
        }
    }
    tx1.clone()
}
```

#### Data Structures

##### 1. Channel State Structure

```rust
#[derive(Debug, Clone)]
pub struct FlashChannelState {
    channel_id: [u8; 32],  // Hash of funding outpoint + agg_pubkey
    funding_outpoint: OutPoint,
    aggregate_pubkey: [u8; 32],
    update_pubkeys: ([u8; 32], [u8; 32]),
    settlement_pubkeys: ([u8; 32], [u8; 32]),
    current_sequence: u32,
    balances: (u64, u64),
    csv_delay: u32,
    trigger_sig: Vec<u8>,
    latest_update_tx: Transaction,
    latest_settlement_tx: Transaction,
}
```

##### 2. RBS Policy Structure

```rust
#[derive(Debug, Clone)]
pub struct RBSPolicy {
    enabled: bool,
    whitelist_templates: Vec<Script>,  // Approved update scripts
    max_sequence_delta: u32,  // Max allowed sequence jump
}
```
