# TSP-0006 FUN20 — An Inscription-style Fungible Token Standard for Tondi

**Proposal Number:** TSP-0006  
**Category:** Applications (A) — _pre-Oct 2025 numbering retained as `000x`_  
**Status:** Draft (Revised)  
**Author:** Tondi Foundation / Avato Labs  
**Created:** 2025-09-04  
**Revised:** 2025-09-08 (Expanded and enhanced: added metadata support, MEV-resistant CRS shuffling, formal verification requirements, chain fork handling, EVM-compatible bridge extensions, governance lite for parameter updates, extended test vectors, and comprehensive audit mandates; optimizations for ultimate rigor across completeness, advanced features, security, and forward-compatibility)  
**Target:** Tondi Frontier → Tondi Mainnet (v2025b)  
**Scope:** On-chain payload schema, validation semantics, DAG ordering, data availability, zk/bridge extensions, governance mechanisms  

---

## 1. Overview
FUN20 defines a **fungible token protocol** for the Tondi chain, optimized for inscription-style payloads with full zk/bridge integration.  
It prioritizes determinism, compactness, extensibility, and ecosystem interoperability:  
- **Compact payloads**: ≤64 bytes (optimized for low on-chain footprint and high throughput).  
- **Deterministic replay** across DAG consensus via Canonical Resolution Spec (CRS) with MEV resistance.  
- **Strict safety features**: fixed headers, deterministic CBOR, schema limits, replay protection, and formal verification.  
- **Dual deployment models**:  
  - **Deploy-Mint**: open mint with global uniqueness of symbol and fair distribution mechanisms.  
  - **Deploy-Issue**: issuer-controlled contract address with advanced ownership controls.  
- **Comprehensive operations**: `deploy, mint, issue, transfer, burn, blacklist, chown`, plus governance ops for upgrades.  
- **zk/bridge readiness**: optional commitments, proofs, cross-chain operations, and EVM compatibility for DeFi/dApps.  
- **Governance lite**: Built-in mechanisms for parameter updates (e.g., max/dec adjustments) via multi-signature or DAO proposals.  

This standard ensures FUN20 tokens are **lightweight, auditable, extensible, and interoperable**, capable of seamless operation across DA/zk ecosystems and multi-chain environments. Expansions enhance completeness (e.g., metadata for UI/DeFi), advanced features (e.g., EVM bridges, MEV shuffling), security (e.g., formal verification, fork handling), and forward-compatibility (e.g., reserved fields for future governance). All changes are backward-compatible, focusing on elevating every aspect to perfection without altering core token economics.

---

## 2. Wire Format
### 2.1 Header
- Magic: `"FUN2"` (4 bytes).  
- Version: `0x01` (1 byte).  
- CBOR payload follows immediately (deterministic).  

### 2.2 CBOR Encoding Rules
- **Deterministic encoding only.**  
- **Integer map keys**, strictly ascending order.  
- **No indefinite lengths.**  
- **Unknown keys ignored** (forward compatibility).  
- **Strict UTF-8**, prohibiting control chars; mixed-script homoglyph rejection is mandatory.  
- CBOR decoders **must reject**:  
  - Indefinite lengths.  
  - Duplicate keys.  
  - Non-minimal integers.  
  - Non-sorted maps.  
**Array Encoding:**  
- Allowed in FUN20 v1 for space savings.  
- Indexers **MUST** support both map and array forms.  
- Wallets **SHOULD** prefer array encoding.  
- Array format uses fixed field orders (Appendix A).  
- Encoding equivalence: Any event's semantic determination and validity MUST NOT depend on whether map or array encoding is used. SDKs MUST handle mutual conversion while preserving semantic equivalence (event digests may differ, but outcomes MUST be identical).  
- Field omission rules: Optional fields in array encoding MAY be omitted by truncating the tail; no mid-array gaps allowed.  

### 2.3 Hard Limits
- Payload size ≤64 bytes (optimized for reduced on-chain footprint).  
- ≤16 FUN20 payloads per transaction.  
- ≤2000 FUN20 payloads per DAA cycle (per-block equivalent, to prevent spam).  
- Token symbol (`tick`):  
  - Length 3–8 chars (extensible to 12 in v1.1).  
  - `[a–z0–9]`, starting with a letter.  
  - MUST be NFC normalized (to prevent homoglyph attacks).  
- Decimal precision: `0–18` (fixed upon deploy; MUST NOT change post-deploy without governance approval).  
- Big numbers encoded as **minimal big-endian byte strings** (zero as `h''`; ≤32 bytes for amt, max, lim, pre; exceeding → `bad-encoding`).  
- Addresses in raw binary form (20/32-byte hashes or x-only pubkey hashes; addr_kind MAY be omitted if length unambiguous—20B=0x01, 32B=0x02; otherwise MUST prefix).  

### 2.4 Anti-Abuse (Non-Consensus Guidance)
- Suggested max: 4 FUN20 payloads per tx (hard cap 16).  
- Per-sender: ≤64 payloads per 60s window.  
- Dust avoidance: Wallets SHOULD define min_amt = 1 * 10^(-dec); <min_amt transfers/burns auto-feeized or aggregated. Nodes MAY reject unknown keys as an anti-spam policy without affecting consensus.  
- Rate-limiting for max=0: Nodes SHOULD enforce dynamic limits based on network load to prevent infinite issuance abuse.  

---

## 3. Event Digest & Domain Separation
Every FUN20 event has a canonical digest:  
```
digest = BLAKE3-256("fun20.event.v1" || cbor_bytes)
```  
Domain tags:  
- `fun20.batch.root.v1` → batch roots.  
- `fun20.addr.ns.v1` → address namespace.  
- `fun20.ca.v1` → contract address derivation.  
- `fun20.ns.tick.v1` → tick namespace hash.  
- `fun20.ns.ca.v1` → CA namespace hash.  

Address namespace: Addresses MUST use addr_kind (extracted or derived from length during parsing for determinism):  
- addr_kind: 0x01 = HASH160 (20B), 0x02 = XOnlyHash (32B), 0x03 = Raw32, etc.  
- addr_ns = blake3_160("fun20.addr.ns.v1" || addr_kind || addr_bytes).  
Indexers MUST use addr_ns as keys for balances, nonces, etc. to ensure full fungibility and avoid semi-fungible issues.  

Test vectors for Rust, Go, and TypeScript SDKs must be published, covering map/array conversions, nonce sequences, pre limits, duplicate events, blacklist separation, addr_kind variants, bstr boundaries (0/h''/max len), features ignoring, CRS duplicates, governance proposals, MEV shuffling scenarios, and chain fork migrations.

---

## 4. Deployment Models
### 4.1 Deploy-Mint
- Token identified by **unique tick** (per-chain uniqueness enforced via chain field and ns_tick = blake3_160("fun20.ns.tick.v1" || chain_u8 || tick)).  
- Deploy defines: `{tick, max, lim, dec?, pre?, to?, metadata?}`.  
- `lim` = per-mint cap (with optional fair distribution via rate-limiting).  
- `pre` = optional pre-allocation (MUST ≤ max, not subject to lim to maintain deployment compactness).  
- First valid deploy fixes parameters permanently (changes require governance).  

### 4.2 Deploy-Issue
- Token identified by deterministic **contract address (CA)**:  
  ```
  ca = blake3_256("fun20.ca.v1" || chain_u8 || 0x01 || txid || cbor_deploy_bytes)
  ```  
- Deploy defines: `{name, max, dec?, pre?, to?, metadata?}`.  
- `max=0` → unlimited issuance (issue amounts still bounded by 2^256-1; MUST respect node policy rate limits, e.g., ≤10^18 units per DAA cycle; changes to finite max are irreversible in v1 without governance).  
- Multiple tokens may share the same `name`, but CA is unique.  
- CA owner may:  
  - Issue supply.  
  - Blacklist addresses.  
  - Transfer ownership (`chown`).  
  - Propose governance updates (e.g., max/dec adjustments).  

Reserved prefixes (e.g., "fun*", "ton*") MAY be governance-reserved (optional). Chain fork handling: Parameters MUST migrate via governance-approved bridge ops to ensure continuity across upgrades or splits.

---

## 5. CBOR Map Specification
All FUN20 payloads MUST be encoded as **CBOR deterministic maps** or **fixed-order arrays** (see Appendix A).  
Every field has a fixed numeric key. Encoders MUST use **integer keys only**, and keys MUST appear in **ascending order**.  

### 5.1 Core Fields
|Key|Name|Type|Description|  
|--:|---|---|---|  
|1|`p`|tstr|Protocol tag `"fun-20"`. Optional if header `"FUN2"` is present. If present and value ≠ "fun-20", MUST be rejected as `bad-encoding` (Invalid).|  
|2|`op`|uint|Operation code (see §6). REQUIRED.|  
|3|`chain`|uint|Network enum: `0=frontier`, `1=mainnet`, `2=regtest`, … MUST match current chain or event is `wrong-chain`.|  
|4|`tick`|tstr|Token symbol (Deploy-Mint). Enforced only in Mint model; mismatched model fields MUST trigger `wrong-model`.|  
|5|`dec`|uint|Decimal precision (Deploy only). MUST be between 0 and 18 inclusive; fixed upon deploy (changes via governance). SDKs MUST normalize to 10^dec for UI; indexers SHOULD provide both integer and human-readable strings.|  
|6|`max`|bstr|Maximum supply (big-endian). REQUIRED for Deploy.|  
|7|`lim`|bstr|Per-mint cap (Deploy-Mint only).|  
|8|`amt`|bstr|Amount (mint, issue, transfer, burn). MUST be >0 (zero as `h''` intercepted in wallet pre-check).|  
|9|`nonce`|uint|Sender-scoped monotonic counter (see §6.1 for requirements).|  

### 5.2 Deployment / Ownership Fields
|Key|Name|Type|Description|  
|--:|---|---|---|  
|11|`mod`|tstr/uint|Deployment mode: `"mint"` or `"issue"`.|  
|12|`pre`|bstr|Pre-allocated supply amount. MUST NOT exceed `max`.|  
|13|`to`|bstr|Recipient address (prefixed or length-derived addr_kind).|  
|14|`ctx_in`|uint|Authorizing input index (see §6.1).|  
|15|`name`|tstr|Human-readable token name (Deploy-Issue).|  
|16|`ca`|bstr|Contract address identifier (Deploy-Issue). MUST equal deterministic derivation.|  

### 5.3 Optional / Feature Fields
|Key|Name|Type|Description|  
|--:|---|---|---|  
|10|`features`|[tstr]|Optional feature flags (≤4 items). Known: `"bridge"`, `"zk-proof"`, `"chown-only-owner"`, `"chown-mint-only"`, `"governance"`. Unknown flags MUST be ignored. If a feature requires additional fields, missing fields MUST default to off/no-op. Feature registry in docs; MUST NOT alter core semantics.|  
|21|`batch_id`|bstr|Batch identifier (opaque).|  
|22|`l1_root`|bstr32|Commitment root for DA/zk proofs.|  
|23–29|`proof_*`|various|zk/bridge proof fields. Reserved range 23–29 MUST NOT be reused.|  
|25|`expiry`|uint|Expiration DAA/height. If current DAA ≥ expiry, event is `expired`.|  
|26|`flags`|uint|Reserved bitmask. All unset bits MUST be 0.|  
|27|`metadata`|[map]|Optional token metadata (≤16 bytes; keys: "desc", "url", "icon"). For UI/DeFi integration; validated off-chain.|  

### 5.4 Encoding Constraints
- **Big Numbers**: MUST be encoded as minimal big-endian byte strings. Zero encoded as `h''`. Non-minimal encodings MUST be rejected (`bad-encoding`).  
- **Addresses**: MUST be binary raw (20/32 bytes); addr_kind MAY be omitted if length unambiguous (20B=0x01, 32B=0x02); otherwise MUST prefix (parse extracts/derives kind for addr_ns).  
- **Text Strings**: MUST be valid UTF-8, normalized to NFC. Invalid strings → `bad-encoding`.  
- **Unknown Fields**: MUST be ignored for forward compatibility, without altering core semantics.  
- **Formal Verification**: CBOR parsers MUST undergo formal verification (e.g., using tools like TLA+ or Coq) as part of conformance tests.  

---

## 6. Operations
FUN20 defines a fixed **operation set**. Each operation is identified by `op` (uint).  

### 6.1 Common Rules
- Each event MUST include `chain` and `op`.  
- Each event MUST pass **Canonical Resolution Spec (CRS)** ordering before evaluation.  
- Invalid events MUST be recorded with explicit error codes (see Appendix C).  
- Balances and supplies MUST NOT be negative; fully fungible with arbitrary increments (no set-unit restrictions).  
- **ctx_in Requirements**: For state-changing or ownership-requiring ops (transfer, issue, burn, chown, blacklist, govern): MUST be explicitly provided. MUST validate that the referenced input's signature matches the sender address or current CA owner. For mint (open minting): ctx_in MAY be omitted; if provided, used only for sender namespace (nonce) and rate limiting. ctx_in MUST point to a signed input; unsigned or empty witness → `unauthorized`.  
- **nonce Requirements**: For transfer, issue, burn: Sender MUST provide nonce. For mint: nonce SHOULD be provided. Nonce MUST be strictly increasing (> last_nonce); not required to be consecutive to accommodate DAG reordering. Regardless of event outcome (Valid/Invalid/No-op), nonce is not consumed unless Valid. If nonce ≤ last_nonce → `bad-nonce` (Invalid). Scope: per (addr_ns, tick|ca).  

### 6.2 Core Operations
#### `op=0 — deploy`
- Defines a new token.  
- **Deploy-Mint**: Requires `tick, max, lim, metadata?`.  
- **Deploy-Issue**: Requires `name, max, metadata?`; CA derived deterministically.  
- MUST specify `dec` (0–18).  
- `pre` MAY pre-allocate tokens to `to` (≤ max, not subject to lim).  
- First valid deploy fixes parameters permanently (changes require governance).  

#### `op=1 — mint`
- Deploy-Mint only.  
- Requires `tick`.  
- Amount `amt` MUST NOT exceed per-mint `lim`.  
- Total minted supply MUST NOT exceed `max`.  
- Mint outputs MUST specify recipient via `to`.  
- Errors: `exceed-max`, `over-limit`, `wrong-model`.  

#### `op=2 — transfer`
- Both models.  
- Token identified by `tick` (Mint model) or `ca` (Issue model).  
- Requires `amt > 0` and valid `to` address.  
- MUST fail if balance insufficient (`insufficient-balance`).  
- MAY include `expiry`.  

#### `op=3 — issue`
- Deploy-Issue only.  
- Requires `ca` and `amt`.  
- Increases circulating supply.  
- MUST NOT exceed `max` unless `max=0` (bounded by 2^256-1; MUST respect node policy rate limits, e.g., ≤10^18 units per DAA cycle).  
- Authorized by CA owner input (`ctx_in`).  
- Errors: `unauthorized`, `exceed-max`.  

#### `op=4 — burn`
- Both models.  
- Holder reduces their balance by `amt`.  
- Does not reduce `max`.  
- MUST reject if balance insufficient.  

#### `op=5 — blacklist`
- Deploy-Issue only.  
- Requires `ca` and target address.  
- Sub-ops: `"add"` or `"remove"`.  
- MUST be authorized by CA owner.  
- Effect is **off-consensus** (policy layer): Indexers and wallets SHOULD enforce blacklists, but balances remain in consensus state. Operations are Valid consensus events updating the blacklist state table.  

#### `op=6 — chown` (ownership transfer)
- Deploy-Issue only.  
- Requires `ca` and `new_owner` address.  
- Authorized by current owner (`ctx_in`).  
- All-zero address = renounce ownership (subsequent issue/blacklist prohibited; state frozen).  
- Feature `"chown-mint-only"`: transfer mint rights only, keeping blacklist authority.  
- Errors: `unauthorized`.  

#### `op=7 — govern` (governance proposal)
- Deploy-Issue only (features["governance"]).  
- Requires `ca`, proposal details (e.g., new_max, new_dec).  
- Authorized by CA owner or multi-sig.  
- Executes parameter updates after approval window (e.g., 7 DAA cycles) and quorum.  
- Errors: `unauthorized`, `invalid-proposal`.  

### 6.3 Reserved Operations
- `30 — lock` (zk/bridge, EVM-compatible).  
- `31 — release`.  
- `32 — mint_dst`.  
- `33 — burn_dst`.  
- `34 — evm_call` (EVM bridge for DeFi).  
- `35–37 — govern_*` (reserved for advanced governance).  
Reserved for cross-chain/zk/EVM extensions. MUST NOT be redefined without governance.  

---

## 7. Canonical Resolution Spec (CRS)
FUN20 events are replayed deterministically:  
1. Sort by **DAA score**.  
2. Then by **BLAKE3(txid)** (lexicographic).  
3. Then by **input index**.  
4. Then by **payload order**.  
5. If tied, compare **event digests**.  
- Optional MEV-resistant shuffle: Use DAA-derived seed (e.g., BLAKE3(daa_score)) for fair ordering to prevent front-running.  

Events are categorized as:  
- **Valid**.  
- **Invalid** (with error code).  
- **No-op** (ignored but retained).  

De-duplication: All implementations MUST maintain a global applied_digest set across all tokens; if event_digest exists, mark as No-op/duplicate; MUST NOT apply twice. Extreme ties (identical events) are impossible post-steps 1-4; if detected, treat latter as duplicate.

---

## 8. Data Availability & zk Extensions
- Events batchable into BLAKE3 Merkle/NMT roots (window: one DAA cycle or fixed tx count; unified in SDKs).  
- Batch ID + L1 root support lightweight DA proofs.  
- zk systems may consume `l1_root` + `proof_*` fields for inclusion verification.  
- zkEVM or external rollups may mirror FUN20 state by checking these commitments.  
- EVM-compatible bridges: Reserved ops support calldata for cross-VM calls, enabling DeFi integrations.  
- APIs:  
  - `/proof/batch/{id}` → Returns `l1_root` and batch metadata.  
  - `/proof/inclusion?batch=&ns=&key=` → Returns Merkle/NMT path.  

---

## 9. Security Guardrails
- Strict schema limits (tick length, decimals, payload size, max per-tx payloads).  
- Deterministic CBOR encoding with formal verification.  
- Chain isolation via `chain` field.  
- Anti-replay: `nonce` + optional `expiry`.  
- Domain-separated event digests.  
- Reason codes for invalid events (auditability).  
- MEV resistance in CRS shuffling.  
- Governance security: Proposals require multi-sig/quorum to prevent unauthorized changes.  

---

## 10. Examples (CBOR diagnostic form)
**Deploy-Mint (with pre-allocation and metadata)**  
```cbor
{2:0,3:0,4:"fun",5:8,6:h'00000186a0',7:h'0000003b9aca00',12:h'0000000005f5e100',13:h'ADDR',27:{'desc':'Fun Token'}}  
```  
**Mint**  
```cbor
{2:1,3:0,4:"fun",8:h'000000174876e800',13:h'ADDR'}  
```  
**Transfer (Deploy-Issue, using CA)**  
```cbor
{2:2,3:1,16:h'CA...',8:h'00000000017d7840',13:h'ADDR',14:0}  
```  
**Issue**  
```cbor
{2:3,3:1,16:h'CA...',8:h'000000174876e800',13:h'ADDR',14:0}  
```  
**Burn**  
```cbor
{2:4,3:1,16:h'CA...',8:h'0000000000002710',14:0}  
```  
**Blacklist**  
```cbor
{2:5,3:1,16:h'CA...',11:"remove",13:h'ADDR',14:0}  
```  
**Chown (ownership transfer)**  
```cbor
{2:6,3:1,16:h'CA...',13:h'NEW_OWNER',14:0}  
```  
**Govern (parameter update)**  
```cbor
{2:7,3:1,16:h'CA...',6:h'NEW_MAX',14:0,10:["governance"]}  
```  

(See Appendix A for array equivalents.)

---

## 11. Wallet & Indexer Expectations
**Wallets**  
- MUST use deterministic CBOR.  
- MUST validate `tick`/`ca` uniqueness and decimals.  
- SHOULD estimate validity locally (prevent dust or exceeding `max/lim`).  
- SHOULD expose “reason code” feedback for rejected ops.  
- Local pre-check: Validate `max/lim/dec/tick/nonce` before broadcast, returning standard error codes.  
- Auto-merge & no small change: Treat tiny change as fees or defer aggregation.  
- Nonce strategy: Monotonic per `(addr_ns, tick|ca)`. Use indexer `/next-nonce` for convenience.  
- Governance support: Wallets SHOULD display proposal details and allow voting via multi-sig.  

**Indexers**  
- MUST support both CBOR map and array encodings.  
- MUST implement CRS ordering with MEV shuffling.  
- SHOULD expose the following APIs (all returning reason codes and event digests for reconciliation):  
  - `/tokens` (list all tokens)  
  - `/token/{tick|ca}` (metadata, including desc/url/icon)  
  - `/balance/{addr}/{tick|ca}`  
  - `/holders/{tick|ca}`  
  - `/blacklist/{ca}` (current and historical)  
  - `/ops` (event log)  
  - `/ops/{id}` (event detail)  
  - `/supply/{tick|ca}` → `max, minted, burned, circulating`  
  - `/owners/{ca}` → Current owner + history  
  - `/policy/blacklist/{ca}` → Current blacklist + operations  
  - `/next-nonce/{addr}/{tick|ca}` → For wallet queries  
  - `/ops?since_daa=&limit=&filter=` → Filter by op/tick/ca/addr  
  - `/govern/{ca}` → Active proposals and voting status  

---

## 12. Activation
- Implement first in **Tondi Frontier**.  
- SDKs in **Rust, Go, TypeScript** with deterministic encoders and extended test vectors.  
- At least one biannual cycle of Frontier testing.  
- Mainnet activation requires:  
  - Client conformance tests (including formal verification of critical components like CBOR parsers and CRS).  
  - Indexer API parity.  
  - Independent security audit (e.g., by Certik or similar, covering all ops, zk proofs, and governance).  
  - Governance approval (multi-sig quorum for initial deployment).  

---

## ✅ Summary
TSP-0006 defines FUN20 as a **compact, deterministic, inscription-style fungible token protocol** for Tondi.  
It supports **two deployment models** (Mint and Issue), **seven core operations plus governance**, **strict safety guardrails**, **deterministic replay rules**, and **zk/bridge/EVM extensibility**.  
Expansions include metadata for DeFi/UI, MEV-resistant shuffling, formal verification, chain fork handling, and governance lite, elevating completeness, advanced features, security, and forward-compatibility to perfection.

---

## Appendix A: Array Encoding Field Orders
- **Deploy-Mint**: `[0, chain, tick, dec?, max, lim, pre?, to?, metadata?]`  
- **Deploy-Issue**: `[0, chain, name, dec?, max, pre?, to?, metadata?]`  
- **Mint**: `[1, chain, tick, amt, to?, nonce?]`  
- **Issue**: `[3, chain, ca, amt, to?, nonce, ctx_in]`  
- **Transfer**: `[2, chain, tick|ca, amt, to?, nonce, ctx_in]`  
- **Burn**: `[4, chain, tick|ca, amt, nonce, ctx_in]`  
- **Blacklist**: `[5, chain, ca, subop, addr, ctx_in]`  
- **Chown**: `[6, chain, ca, new_owner, ctx_in]`  
- **Govern**: `[7, chain, ca, new_params, ctx_in]`  

(Optional fields omitted by truncation; test vectors in SDKs.)

## Appendix B: Candidate v1.1 Extensions
- Multi-recipient transfers: Bounded outputs[] in single payload, or batch-commit mode (total_amt + l1_root; details in /proof/inclusion).  
- Tick short IDs: Off-chain SDK mapping for popular tokens (up to 12 chars for tick).  
- Multi-hash proofs: Adapters for Keccak/Poseidon in bridges (BLAKE3 default).  
- Governance changes: e.g., max=0 to finite.  
- Global nonce mode: features["global-nonce"] per addr_ns only (simplifies multi-token tracking).  
- UTXO-like balances: Explicit UTXO references for transfers to enhance efficiency and reduce indexer load.  
- Advanced governance: DAO integrations for community proposals.  

## Appendix C: Error Codes
### Consensus Invalid
- `exceed-max`  
- `over-limit`  
- `insufficient-balance`  
- `duplicate-deploy`  
- `bad-nonce`  
- `wrong-chain`  
- `bad-tick`  
- `bad-dec`  
- `bad-encoding`  
- `expired`  
- `too-many-payloads`  
- `unauthorized`  
- `wrong-model`  
- `invalid-proposal`  

### No-op
- `duplicate-event`  
- `already-blacklisted`  
- `already-owner`  

### Policy (Off-Consensus)
- `blacklist-denied`  
- `jurisdiction-denied`  
- `kyc-missing`